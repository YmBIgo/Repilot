## 1ページ目 【経験】膨大な量のK8sコードリーディング

- 最初は kubectl, api-server くらいしか見てなかったから、なんとかなった
- 調べれば調べるほど、kube-scheduler, kubelet, kube-proxy, kube-aggregater などの k8sの主要機能から、外部のプラグインの argo-cd, prometheus など機能が多すぎて、k8sの奥深さに絶望した
> コードリーディングを支援するツールを作りたい

## 2ページ目 OSS を読むのは大変

1. コードを読むのが単純に面倒
2. 初見だとどれが重要な関数かわからない
3. 探索が間違った時に戻るのが面倒で間違いやすい
4. 一生で目だけで読める OSS の数は限られてくる

## 3ページ目 OSSの絶望を解決するリーディング支援

1. LLM にコードを読ませる。人間は LLM の出した候補から探索したい経路を選択するだけ
2. 探索が間違っていたら、探索履歴から元の関数に戻れる
3. 探索のサマリーを出力できる
> みたいな「ポチポチ押すだけの」コードリーディングエージェントを作りたい

## 4ページ目 リーディング支援ツールの実現可能性１

- Vulnhuntr という OSS セキュリティスキャンツールが、関数探索の重要な参考になった
- https://github.com/protectai/vulnhuntr

## 5ページ目 リーディング支援ツールの実現可能性２

- Vulnhuntr の仕組み
 1. 関数の中身をLLMに渡し、セキュリティ的に危なそうな関数を抽出
 2. 抽出した関数の中身を再度抽出し、再度 LLM に新しい関数の中身を渡す
 3. 1〜2を指定した深さまで続ける
> LSP と LLM の組み合わせ技で作られている

## 6ページ目 リーディング支援ツールの実現可能性３

- Vulnhuntr を参考に考えた、作ってみたい関数探索の手法
 1. エントリーポイントのファイルと関数とコードリーディングの目的入力
 2. １の関数の中身を取得し、LLM にその中の重要な関数を抽出してもらう
 3. ユーザーは探索したい関数を選び、再度関数の中身を取得し、LLMに渡す
 4. 2〜3をユーザーがいいと思うまで続ける
> LSP と LLM の組み合わせ技で作れる

## 7ページ目 実際に作ってみた

Go言語版のコードリーディングツールを VSCode 拡張機能で作ってみた
 - [Repilot, The First Read Code Agent using LLM](https://marketplace.visualstudio.com/items?itemName=coffeecupjapan.repilot)
 - [【OSSもLLMに読ませよう！】Code Reading Agent を作るのはいいぞ](https://zenn.dev/coffeecupjp/articles/89bb2b40ced6eb)
 - [【Go言語をLLMで読むVSCode拡張を作りました】K8sのソースコードをLLMで爆速で読もう！ハンズオン](https://zenn.dev/coffeecupjp/articles/370fc024d59902)
 - [Repilot デモ動画](https://www.youtube.com/watch?v=SXU8dG6u330)

## 8ページ目 実際に動かしてみる０

- 環境構築
 - Repilot を VSCode Market place からダウンロード
 - Gopls をダウンロード　`brew install gopls`
 - Claude の APIキーを取得　Anthropic APIの取り扱い を参考
 - Go の好きなプロジェクトをclone　今回は k8s で動かしてみます

## 9ページ目 実際に動かしてみる１

- Repilot を起動
 - 「Command + Shift + p」でコマンドパレットを開き、「Open repilot at new tab」をクリック

## 10ページ目 実際に動かしてみる２

- Repilot の設定をする
 - 最初の ChatView の上の方の「Here」をクリック
 - １の後で出てくる設定画面で、全ページで用意した APIキー・goplsのパス・言語を設定

## 11ページ目 実際に動かしてみる３

- 探索したいコードのエントリーポイントを探し（今回は K8s のkubectl で考える）、ChatView で入力
 1. 「[１：k8sのエントリーポイントを探す](https://zenn.dev/coffeecupjp/articles/370fc024d59902#１：k8sのエントリーポイントを探す)」を参考に、エントリーポイントのファイルパス・関数名を確認
 2. repilotを設定画面からChatView に戻り、エントリーポイントのファイルパス・関数名・コードリーディングの目的を入力（「[３：Repilotを開始する](https://zenn.dev/coffeecupjp/articles/370fc024d59902#２：repilot-を初期化する)」を参考に実行）
 3. 最後に「Start Task」をクリック

## 12ページ目 実際に動かしてみる４

- 探索開始、関数の探索経路を制御する
 1. エントリーポイント関数の中身から重要な関数をLLMが最大５つピックアップするので、探索したい関数を入力
 2. 再度 gopls が新しい関数を検索し、その中身をLLMに渡し再度５つまで重要な関数をピックアップ
 3. １〜２をユーザーがOKと思うまで続ける
> ５を入力すれば再検索できる

## 13ページ目 実際に動かしてみる５

- 関数探索の経路の表示・前の探索経路に戻る
 - 前ページで６を入力すれば、関数探索の経路も表示できる
 - 関数探索の経路の木構造のツリーから、前に探索した探索経路に戻ることもできる

## 14ページ目 実際に動かしてみる６

- 探索結果のサマリレポートを出力する
 - ７を入力すれば、ここまでの探索の結果をまとめたサマリレポートを表示することもできる

## 15ページ目 実際のユースケース

- 関数の経路は分かるが、関数の中身までわかるわけではない
 - 最終的には関数の中身をみる必要は出てくる
 - が、関数の経路を探すので迷子になることは大幅に少なくなる

## 16ページ目 今後追加したい機能

1. 関数のマーメイド図（Mermaid.js）出力機能
2. OpenAIやGeminiなど他LLMへの対応
3. C, Java, TypeScript 対応
4. 数字や文字を入力するのではなく、ボタンをクリックするUIにする

## 17ページ目 おわりに

😭「コードを読むのが遅いから貢献できない」
👍「AIと一緒なら、コードリーディングも怖くない」
みたいな体験を、より多くの人に広げられたらと思っています。
